"""Sentinel-1 ECC program."""

from __future__ import annotations

import types
import warnings
import itertools
from typing import NamedTuple
from collections.abc import Mapping, Iterator, Sequence

from .enums import (
    ESwath,
    EEccNumber,
    ESensorMode,
    ESignalType,
    ESequenceType,
)


class PulseType(NamedTuple):
    """Basic pulse info."""

    swath: ESwath
    signal: ESignalType


class EccSequenceItem:
    """Elementary item of an ECC sequence.

    The EccSequenceItem is the an elementary sequence of pulses
    all sharing the same signal type (`sigtype`) and `swath`.

    The number of pulses (repetitions) in the elementary sequence
    is `count`.
    """

    def __init__(self, sigtype: ESignalType, swath: ESwath, count: int = 1):
        """Initialize the EccSequenceItem.

        Parameters
        ----------

        sigtype : ESignalType
            signal type of the pulses generated by the sequence
        swath : ESwath
            swath identifier for pulses generated by the sequence
        count : int
            number pf pulses generated by the sequence (default: 1)

        """
        self._signal_type = ESignalType(sigtype)
        self._swath = ESwath(swath)
        self._count = count
        if count < 0:
            raise ValueError(f"invalid count value: {count!r}")

    @property
    def signal_type(self) -> ESignalType:
        """Signal type."""
        return self._signal_type

    @property
    def swath(self) -> ESwath:
        """Swath."""
        return self._swath

    def __len__(self) -> int:
        return self._count

    def __iter__(self) -> Iterator[PulseType]:
        yield from itertools.repeat(
            PulseType(self._swath, self._signal_type), self._count
        )


class EccSequence:
    """ECC Sequence.

    The EccSequence is composed by as sequence of :class:`EccSequenceItem`.

    Each sequence has an associated type described by the
    :class:`EEccSequenceType` enumeration.

    An EccSequence can be repeated or not in the ECC program depending
    on the value associated to the :data:`EccSequence.repeat` property.
    """

    def __init__(
        self,
        sequence_type: ESequenceType | str,
        items: Sequence[EccSequenceItem],
        *,
        repeat: bool = False,
    ):
        """Initialize the EccSequence.

        Parameters
        ----------

        sequence_type : ESequenceType
            the type of the sequence ()"PREAMBLE", "POSTAMBLE" or
            "IMAGING" sequence)
        items : Sequence[EccSequenceItems]
            a sequence of :class:`EccSequenceItems` composing the EccSequence.
            Sequence items can have different signal types or swath
            identifiers associated to them.
        repeat : bool
            keyword only argument that specifies if the sequence can be
            repeated or not in the ECC program (default: `False`).

        """
        self._sequence_type: ESequenceType = ESequenceType(sequence_type)
        self._items = items
        self._repeat = bool(repeat)

    @property
    def sequence_type(self) -> ESequenceType:
        """Sequence type."""
        return self._sequence_type

    @property
    def repeat(self) -> bool:
        """Flag specifying if the sequence can be repeated or not."""
        return self._repeat

    def __len__(self) -> int:
        return sum(len(item) for item in self._items)

    def __iter__(self) -> Iterator[PulseType]:
        for item in self._items:
            yield from iter(item)

    def get_isp_count(self) -> int:
        """Return the number of ISP of the sequence."""
        return sum(
            len(item)
            for item in self._items
            if item.signal_type != ESignalType.SILENT
        )


class NoExactRepetitionError(ValueError):
    """The number of repetitions does not ensure to math the target exactly."""


SwathMapType = Mapping[int, ESwath]


class EccProgram:
    """Sentinel-1 ECC program.

    An ECC program is always associated to a specific sensor mode
    (:class:`ESensorMode`) and to a specific ECC program identifier
    (see :class:`EEccNumber`).

    It is composed by exactly 3 (three) sequences ("PREAMBLE", "IMAGING"
    sequence, and "POSTAMBLE"), and each of them can be repeated or not
    during the the program execution.
    """

    def __init__(
        self,
        mode: ESensorMode,
        ecc_number: EEccNumber,
        sequences: Sequence[EccSequence] | None = None,
        swath_map: SwathMapType | None = None,
        *,
        repetitions: int = 1,
    ):
        """Initialize the EccProgram.

        Parameters
        ----------
        mode : ESensorMode
            sensor mode implemented by the program
        ecc_number : EEccNumber
            unique ECC number identifying the program
        sequences : Sequence[EccSequence] | None,
            a sequence of at most three :class:`EccSequence` ("PREAMBLE",
            "IMAGING" sequence, and "POSTAMBLE"). If any of them is not
            specified then an empty one is assumed (i.e. am sequence with
            zero items). The default value for this parameter is `None`
            meaning that all the sequences are initialized with empty
            instances of :class:`EccSequence`.
        swath_map : SwathMapType | None
            a dictionary associating the swath number (int) with the swath
            identifier (:class:`ESwath`) or the ECC program.
        repetitions: int
            number of time the the "IMAGING" sequence is repeated during
            the program (default: 1).

        """
        self._mode = ESensorMode(mode)
        self._ecc_number = EEccNumber(ecc_number)
        self._sequences = self._init_sequences(sequences)
        self.repetitions = repetitions  # NOTE: use the property setter here

        swath_map = swath_map if swath_map is not None else {}
        self._swath_map = types.MappingProxyType(swath_map)

    @staticmethod
    def _init_sequences(sequences) -> dict[ESequenceType, EccSequence]:
        # check for multiple sequences of the same type
        seq_map: dict[ESequenceType, EccSequence] = {}
        if sequences is not None:
            for seq in sequences:
                if seq.sequence_type in seq_map:
                    raise ValueError(
                        f"EccProgram with multiple {seq.sequence_type.name!r} "
                        "sequences not allowed"
                    )
                seq_map[seq.sequence_type] = seq

        # ensure that the map is complete
        out: dict[ESequenceType, EccSequence] = {
            ESequenceType.PREAMBLE: EccSequence(ESequenceType.PREAMBLE, []),
            ESequenceType.IMAGING: EccSequence(ESequenceType.IMAGING, []),
            ESequenceType.POSTAMBLE: EccSequence(ESequenceType.POSTAMBLE, []),
        }
        out.update(seq_map)

        # check consistency of the "repeat" parameter
        if out[ESequenceType.PREAMBLE].repeat:
            warnings.warn(
                "'repeat' attribute unexpectedly set to true for the "
                "'preamble' sequence",
                stacklevel=3,
            )
        if out[ESequenceType.POSTAMBLE].repeat:
            warnings.warn(
                "'repeat' attribute unexpectedly set to true for the "
                "'postamble' sequence",
                stacklevel=3,
            )

        return out

    @property
    def mode(self) -> ESensorMode:
        """Sensor mode."""
        return self._mode

    @property
    def ecc_number(self) -> EEccNumber:
        """ECC number."""
        return self._ecc_number

    @property
    def swath_map(self) -> SwathMapType:
        """Return the (immutable) mapping between ecc_number and swath enum."""
        return self._swath_map

    @property
    def repetitions(self) -> int:
        """Number of times the imaging sequence is repeated in the program."""
        return self._repetitions

    @repetitions.setter
    def repetitions(self, repetitions: int):
        """Set Number of times the imaging sequence is repeated in the program.

        The input value mus be positive to zero.
        If a value greater than one is specified and the imaging sequence
        is not supposed to be repeated (according to its "repeat" attribute),
        a warning is raised.
        """
        if repetitions < 0:
            raise ValueError(
                "repetitions must be a positive integer: "
                f"repetitions={repetitions} is not allowed"
            )
        if (
            repetitions > 1
            and not self._sequences[ESequenceType.IMAGING].repeat
        ):
            warnings.warn(
                f"{repetitions} repetition requested but the imaging sequence "
                "is configured with 'repeat=False'",
                stacklevel=2,
            )
        if int(repetitions) != repetitions:
            raise TypeError("'repetitions' must be an integer")
        self._repetitions = int(repetitions)

    @property
    def preamble(self) -> EccSequence:
        """Preamble sequence of the ECC program."""
        return self._sequences[ESequenceType.PREAMBLE]

    @property
    def imaging(self) -> EccSequence:
        """Imaging sequence of the ECC program."""
        return self._sequences[ESequenceType.IMAGING]

    @property
    def postamble(self) -> EccSequence:
        """Postamble sequence of the ECC program."""
        return self._sequences[ESequenceType.POSTAMBLE]

    def iter_sequences(self) -> Iterator[EccSequence]:
        """Iterate over sequences of the ECC program."""
        yield self.preamble
        yield from itertools.repeat(self.imaging, self.repetitions)
        yield self.postamble

    def __len__(self) -> int:
        return sum(len(sequence) for sequence in self.iter_sequences())

    def __iter__(self) -> Iterator[PulseType]:
        for sequence in self.iter_sequences():
            yield from iter(sequence)

    def compute_repetitions(self, target: int, *, strict: bool = False) -> int:
        """Compute the number of repetitions of the imaging sequence.

        Given a target number of ISPs for the data'take, this method
        computes the number of repetitions of the imaging sequence
        also considering the number of ISPs in the preamble and postamble,
        and SILENT echoes.
        """
        if target < 0:
            raise ValueError(f"{target!r} cannot me negative")

        preamble_len = self.preamble.get_isp_count()
        postambe_len = self.postamble.get_isp_count()
        imaging_len = self.imaging.get_isp_count()
        target_imaging_len = target - preamble_len - postambe_len

        if target_imaging_len < 0:
            if strict:
                raise NoExactRepetitionError(
                    "the target ISP count is smaller than preamble +"
                    " postamble",
                )
            return 0
        if strict and (target_imaging_len % imaging_len != 0):
            raise NoExactRepetitionError(
                "the number of repetitions does not ensure an exact match "
                f"with the target number of ISPs ({target})"
            )
        return target_imaging_len // imaging_len
